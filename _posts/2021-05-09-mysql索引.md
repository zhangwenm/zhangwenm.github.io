---
layout: post
title: mysql索引
date: 2021-05-09
tags: [mysql,索引]
---

索引
----

###### 索引基础
索引的目的在于提高查询效率，可以类比字典。例如我们查找mysql，首先我们定位m，然后定位y，然后再找到剩下的sql。
如果没有索引的话，我们可能需要再所有内容里进行匹配查找。索引就是不断缩小想要获得数据的范围，最终筛选出想要的数据，
同时把随机的事件，变成顺序事件。

###### 磁盘io喝预读
考虑到磁盘io是非常高昂的操作，计算机操作系统做了一些优化。当一次磁盘IO时，不光把当前磁盘地址的数据，而且把相邻地址
的数据也读取到内存缓冲区，因为局部与毒性原理告诉我们，当计算机访问一个地址的数据时候，于其相邻的数据将很快被访问到。
每一次IO读取的数据我们称之为一页，具体一页的大小和操作系统有关，一般为4k或者8k。


###### b+树
mysql innodb引擎的索引数据结构为B+树，每一个节点的大小为一页。因为数据存储再叶子节点上，查找数据时io次数与树高有关。
而B+树有更低的树高。由于树的每一个节点都是一个磁盘块，大小是固定的，上边存储的数据项。因此数据项占的空间越小，放的数据
项的数量越多，树高就越低。
当B+树的数据项时符合数据结构时，（name,age,sex）时，B+树遵循有左至右进行匹配，也就是说会先找出name相同的，然后再匹配age，sex。
如果没有name，（20，F）这样的数据来的时候，B+树就不知道下一步该区那个节点查找，所以就会失效。因为建立索引的时候name就是第一个因子，
必须要根据name才能知道下一步该区哪里进行查找。（张三，F）这样的数据，会先匹配name，因为没有age，会直接匹配性别。这就是最左匹配原则。

###### 索引建立原则
1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

###### 索引类型
哈希表
有序数组
搜索树
哈希表：以键值对的形式来存储数据的结构，等值查询快，但是不能进行范围查询
有序数组：范围查询和等值查询效率都很高，但是插入数据时成本较高，适合静态存储引擎，即数据表一旦建立就不再修改

